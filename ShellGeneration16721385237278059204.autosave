import controlP5.*;
import processing.data.XML;
import java.io.File;
import java.io.PrintWriter;
import java.util.ArrayList;
import processing.serial.*;
import processing.opengl.*;

float rotX = 0;
float rotY = 0;
float lastMouseX, lastMouseY;
float zoom = 1;
boolean isDragging = false;
boolean isPanning = false;
float panX = 0;
float panY = 0;
boolean isDraggingControlVertex = false;

int numberOfStepGrowth = 50;
float bendAngle = 0.3f;
float twistAngle = 0.05f;
float initGVL = 1.5f;
float initSVL = 3f;
float sideShift = 0;
float growthRate = 1.03f;
float shellThickness = 1.0f;  // 默认厚度
float openingFlatten = 0.0f;   // 0 表示圆形，1 表示扁平化最大
float openingRotationDeg = 0.0f; // 旋转角度（度）

// 顶点数量控制（默认 12，可扩展）
static final int MIN_VERTEX_COUNT = 12;
static final int MAX_VERTEX_COUNT = 36;
int vertexCount = MIN_VERTEX_COUNT;

PVector[] shape;
PVector[][] rings;
PVector[][] ringsOuter;
PVector[][] ringsInner;
PVector[][] outerNormals;
PVector[][] innerNormals;
float[] GVLength = new float[100];
float[] SVLength = new float[100];
PVector[] normGV = new PVector[100];
PVector[] normSV = new PVector[100];
PVector[] GV = new PVector[100];
PVector[] SV = new PVector[100];
PVector[] CV = new PVector[100];

PVector[] controlVertices;
boolean[] dragging;

ArrayList<PVector> exportVertices;
ArrayList<int[]> exportFaces;

ArrayList<ShellState> undoStack = new ArrayList<ShellState>();
ArrayList<ShellState> redoStack = new ArrayList<ShellState>();
int maxUndoSteps = 10;
boolean isUndoingOrRedoing = false;  // 防止在撤销/重做时重复记录状态

// 参数集列表
ArrayList<ParameterSet> parameterSets = new ArrayList<ParameterSet>();
int currentParameterSetIndex = 0;

float autoRotateSpeed = -0.003; // 负值表示逆时针旋转
boolean isAutoRotating = false; // 控制是否自动旋转

// 添加115200串口支持
Serial controlPort;  // 115200串口对象
String controlData = "";  // 存储控制数据

PShader shellShader;
int backgroundTopColor;
int backgroundBottomColor;
PImage backgroundGradient;
boolean gradientNeedsUpdate = true;

void setup() {
  fullScreen(P3D);
  shellShader = loadShader("shellFrag.glsl", "shellVert.glsl");
  configureShellShader();
  backgroundTopColor = color(0x19, 0x19, 0x19);
  backgroundBottomColor = color(0xbc, 0xe1, 0xe7);
  gradientNeedsUpdate = true;
  
  initSerial();
  
  cp5 = new ControlP5(this);
  
  initializeShapesAndRings(); // 确保在调用任何用 shape 的方法之前初始化它
  setupInterface();           // 初始化界面控件
  setupControlVertices();     // 初始化控制顶点
  loadParametersFromXML();    // 加载参数集
  updateDropdownParameterSets(); // 更新下拉列表
  resetVectors();             // 置向量
  saveState();                // 保存初始状态

  rotX = radians(-17.5);
  rotY = radians(0);
  panX = 35;
  panY = -375;
  zoom = 5.5;
}

void draw() {
  processSerial();

  drawBackgroundGradient();
  
  // 默认光照会在每帧被重置，补回灯光以获得与旧版相同的明暗效果
  lights();

  // 实时更新参数
  updateParametersFromSliders();

  resetVectors();

  // 如果启用了自动旋转，更新rotY
  if (isAutoRotating) {
    rotY += autoRotateSpeed;
  }

  pushMatrix();
  translate(width / 2 + panX, height / 2 + panY);
  scale(zoom);
  rotateX(rotX);
  rotateY(rotY);

  if (radio.getValue() == 1) {
    drawOpenRings();
  } else if (radio.getValue() == 2) {  // Show Shell Surface
    drawWireSurface();  // 现在显示线框表面
  } else {  // Show Surface (值为3)
    if (shellShader != null) {
      shader(shellShader);
      drawSurface();      // 现在显示实体表面
      resetShader();
    } else {
      drawSurface();
    }
  }

  popMatrix();

  drawInterface();
  drawControlInterface();
  updateShapeFromControlVertices();
  
}

void resetParameters() {
    // 重置所有参数为指定的默认值
    setVertexCount(MIN_VERTEX_COUNT, false);
    numberOfStepGrowth = 50;
    bendAngle = 0.3;  // 60/200 因为界面值要除以200
    twistAngle = 0.05;  // 50/1000 因为界面值要除以1000
    initGVL = 1.5;  // 60/40 因为界面值要除以40
    initSVL = 3.0;  // 30/10 因为界面值要除以10
    sideShift = 0;
    shellThickness = 1;
    openingFlatten = 0;
    openingRotationDeg = 0;
    
    // 重置当前参数集索引
    currentParameterSetIndex = -1;
    
    // 更新滑块显示
    if (sliderVertexCount != null) {
        sliderVertexCount.setValue(vertexCount);
    }
    sliderGrowthStep.setValue(50);  // Growth
    sliderBendAngle.setValue(60);   // Bending Angle
    sliderTwistAngle.setValue(50);  // Twisting Angle
    sliderConeHight.setValue(60);   // Cone Height
    sliderConeWidth.setValue(30);   // Cone Width
    sliderSideShift.setValue(0);    // Side Shift
    sliderThickness.setValue(1);    // Thickness
    sliderOpeningFlatten.setValue(0);
    sliderOpeningRotation.setValue(0);
    
    // 设置下拉菜单显示"New Parameter"
    cp5.getController("Parameter Sets").setCaptionLabel("New Parameter");
    
    // 更新截面形状
    updateShapeFromControlVertices();
    // 重置向量
    resetVectors();
}

void initializeShapesAndRings() {
  shape = new PVector[vertexCount];
  float angleStep = TWO_PI / vertexCount;
  for (int i = 0; i < vertexCount; i++) {
    // 半径固定为 1，角度等分（与 ShellShapeGenerator.js 保持一致）
    shape[i] = new PVector(1, angleStep * i, 0);
  }

  rings = new PVector[100][vertexCount];
  ringsOuter = new PVector[100][vertexCount];
  ringsInner = new PVector[100][vertexCount];
  outerNormals = new PVector[100][vertexCount];
  innerNormals = new PVector[100][vertexCount];

  for (int i = 0; i < 100; i++) {
    for (int j = 0; j < vertexCount; j++) {
      rings[i][j] = new PVector(0, 0, 0);
      ringsOuter[i][j] = new PVector(0, 0, 0);
      ringsInner[i][j] = new PVector(0, 0, 0);
      outerNormals[i][j] = new PVector(0, 0, 1);
      innerNormals[i][j] = new PVector(0, 0, -1);
    }
  }

  for (int i = 0; i < 100; i++) {
    GVLength[i] = initGVL * pow(growthRate, i);
    SVLength[i] = initSVL * pow(growthRate, i);
    normGV[i] = new PVector(0, 0, 0);
    normSV[i] = new PVector(0, 0, 0);
    GV[i] = new PVector(0, 0, 0);
    SV[i] = new PVector(0, 0, 0);
    CV[i] = new PVector(0, 0, 0);
  }

  controlVertices = new PVector[vertexCount];
  dragging = new boolean[vertexCount];
  PVector center = getControlCenter();
  for (int i = 0; i < vertexCount; i++) {
    controlVertices[i] = new PVector(center.x, center.y);
  }
}

void setVertexCount(int newCount) {
  setVertexCount(newCount, true);
}

void setVertexCount(int newCount, boolean preserveShape) {
  int constrainedCount = constrain(newCount, MIN_VERTEX_COUNT, MAX_VERTEX_COUNT);
  if (constrainedCount == vertexCount) {
    return;
  }

  PVector[] previousControls = null;
  if (preserveShape && controlVertices != null) {
    previousControls = new PVector[controlVertices.length];
    for (int i = 0; i < controlVertices.length; i++) {
      previousControls[i] = controlVertices[i].copy();
    }
  }

  vertexCount = constrainedCount;
  initializeShapesAndRings();

  if (previousControls != null && previousControls.length > 0) {
    PVector[] resampled = resampleControlVertices(previousControls, vertexCount);
    applyControlVertices(resampled);
  } else {
    setupControlVertices();
    updateShapeFromControlVertices();
  }

  resetVectors();
}

PVector[] resampleControlVertices(PVector[] source, int targetCount) {
  if (source == null || source.length == 0) {
    return createDefaultControlVertices(targetCount);
  }

  int sourceCount = source.length;
  PVector center = getControlCenter();
  PVector[] polar = new PVector[sourceCount];
  for (int i = 0; i < sourceCount; i++) {
    float radius = PVector.dist(source[i], center);
    float angle = atan2(source[i].y - center.y, source[i].x - center.x);
    polar[i] = new PVector(radius, angle);
  }

  PVector[] result = new PVector[targetCount];
  for (int i = 0; i < targetCount; i++) {
    float t = ((float)i / targetCount) * sourceCount;
    int idx0 = floor(t) % sourceCount;
    int idx1 = (idx0 + 1) % sourceCount;
    float frac = t - floor(t);

    float radius = lerp(polar[idx0].x, polar[idx1].x, frac);
    float angle = lerpAngle(polar[idx0].y, polar[idx1].y, frac);

    float px = center.x + cos(angle) * radius;
    float py = center.y + sin(angle) * radius;
    result[i] = new PVector(px, py);
  }

  return result;
}

PVector[] createDefaultControlVertices(int count) {
  PVector[] defaults = new PVector[count];
  float angleStep = TWO_PI / count;
  float controlRadius = 50;
  PVector center = getControlCenter();
  for (int i = 0; i < count; i++) {
    float angle = i * angleStep;
    float px = center.x + cos(angle) * controlRadius;
    float py = center.y + sin(angle) * controlRadius;
    defaults[i] = new PVector(px, py);
  }
  return defaults;
}

void applyControlVertices(PVector[] newVertices) {
  if (newVertices == null || newVertices.length != vertexCount) {
    setupControlVertices();
  } else {
    for (int i = 0; i < vertexCount; i++) {
      if (controlVertices[i] == null) {
        controlVertices[i] = new PVector();
      }
      controlVertices[i].set(newVertices[i]);
    }
  }
  updateShapeFromControlVertices();
}

float lerpAngle(float a, float b, float t) {
  float diff = atan2(sin(b - a), cos(b - a));
  return a + diff * t;
}

void resetVectors() {
  // 初始化方向向量
  normGV[0] = new PVector(0, 0, 1);
  normSV[0] = new PVector(0, 1, 0);

  // 应用生长率计算实际长度
  for (int i = 0; i < numberOfStepGrowth; i++) {
    GVLength[i] = initGVL * pow(growthRate, i);
    SVLength[i] = initSVL * pow(growthRate, i);
  }

  // 基础向量（与 JS 版本一致）
  GV[0] = PVector.mult(normGV[0], GVLength[0]);
  SV[0] = PVector.mult(normSV[0], SVLength[0]);
  CV[0] = GV[0].copy();
  
  for (int i = 1; i < numberOfStepGrowth; i++) {
    normGV[i] = rotation(normGV[i-1], normSV[i-1], bendAngle);
    normGV[i].normalize();
    normSV[i] = rotation(normSV[i-1], normGV[i], twistAngle);
    normSV[i].normalize();
    
    GV[i] = PVector.mult(normGV[i], GVLength[i]);
    SV[i] = PVector.mult(normSV[i], SVLength[i]);
    
    CV[i] = PVector.add(CV[i-1], GV[i]);
  }
  
  for (int i = 0; i < numberOfStepGrowth; i++) {
    // 侧向偏移基向量（SV 旋转 90 度）
    PVector vertical = rotation(SV[i], normGV[i], HALF_PI);
    PVector vertical2 = PVector.mult(vertical, sideShift);

    for (int j = 0; j < vertexCount; j++) {
      float angle = shape[j].y - HALF_PI;
      PVector vv1 = rotation(SV[i], normGV[i], angle);
      vv1.mult(shape[j].x);

      PVector vv2 = PVector.add(vertical2, vv1);

      PVector ringPoint = PVector.add(CV[i], vv2);
      rings[i][j] = ringPoint;

      // 计算外环和内环
      PVector normal = vv1.copy();
      normal.normalize();
      PVector offset = PVector.mult(normal, shellThickness / 2);

      ringsOuter[i][j] = PVector.add(ringPoint, offset);
      ringsInner[i][j] = PVector.sub(ringPoint, offset);
    }
  }

  computeSurfaceNormals();
}

void computeSurfaceNormals() {
  if (numberOfStepGrowth < 1) {
    return;
  }

  for (int i = 0; i < numberOfStepGrowth; i++) {
    int prevRingIndex = max(i - 1, 0);
    int nextRingIndex = min(i + 1, numberOfStepGrowth - 1);

    for (int j = 0; j < vertexCount; j++) {
      int prevJ = (j - 1 + vertexCount) % vertexCount;
      int nextJ = (j + 1) % vertexCount;

      PVector forward = PVector.sub(ringsOuter[nextRingIndex][j], ringsOuter[prevRingIndex][j]);
      PVector around = PVector.sub(ringsOuter[i][nextJ], ringsOuter[i][prevJ]);
      PVector normal = around.cross(forward);

      if (normal.magSq() < 1e-6f) {
        normal = PVector.sub(ringsOuter[i][j], CV[i]);
      }
      if (normal.magSq() < 1e-6f) {
        normal = new PVector(0, 0, 1);
      }
      normal.normalize();

      outerNormals[i][j].set(normal);
      innerNormals[i][j].set(-normal.x, -normal.y, -normal.z);
    }
  }
}

PVector rotation(PVector a, PVector b, float angle) {
  float cosAngle = cos(angle);
  float sinAngle = sin(angle);
  PVector result = new PVector(
    (cosAngle + b.x * b.x * (1 - cosAngle)) * a.x + (b.x * b.y * (1 - cosAngle) - b.z * sinAngle) * a.y + (b.z * b.x * (1 - cosAngle) + b.y * sinAngle) * a.z,
    (b.x * b.y * (1 - cosAngle) + b.z * sinAngle) * a.x + (cosAngle + b.y * b.y * (1 - cosAngle)) * a.y + (b.y * b.z * (1 - cosAngle) - b.x * sinAngle) * a.z,
    (b.z * b.x * (1 - cosAngle) - b.y * sinAngle) * a.x + (b.y * b.z * (1 - cosAngle) + b.x * sinAngle) * a.y + (cosAngle + b.z * b.z * (1 - cosAngle)) * a.z
  );
  return result;
}

void drawOpenRings() {
  float strokeWeightValue = 1 / zoom; // 保持缩放一致的线条宽度
  strokeWeight(strokeWeightValue);
  int ringCount = getVisibleRingCount();
  if (ringCount <= 0) {
    return;
  }
  for (int i = 0; i < ringCount; i++) {
    beginShape();
    for (int j = 0; j < vertexCount; j++) {
      PVector point = getAnimatedRingPoint(i, j);
      vertex(point.x, point.y, point.z);
    }
    PVector firstPoint = getAnimatedRingPoint(i, 0);
    vertex(firstPoint.x, firstPoint.y, firstPoint.z);
    endShape();
  }
}

void drawSurface() {
  int ringCount = getVisibleRingCount();
  if (ringCount < 2) {
    return;
  }

  pushStyle();
  noStroke();
  fill(248, 246, 242);

  // 绘制外表面
  if (shellShader != null) {
    shellShader.set("uInteriorFactor", 0.0f);
  }
  for (int i = 0; i < ringCount - 1; i++) {
    for (int j = 0; j < vertexCount; j++) {
      int nextJ = (j + 1) % vertexCount;
      PVector outer00 = getAnimatedOuterPoint(i, j);
      PVector outer10 = getAnimatedOuterPoint(i + 1, j);
      PVector outer11 = getAnimatedOuterPoint(i + 1, nextJ);
      PVector outer01 = getAnimatedOuterPoint(i, nextJ);
      beginShape(QUADS);
      emitVertexWithNormal(outer00, outerNormals[i][j]);
      emitVertexWithNormal(outer10, outerNormals[i + 1][j]);
      emitVertexWithNormal(outer11, outerNormals[i + 1][nextJ]);
      emitVertexWithNormal(outer01, outerNormals[i][nextJ]);
      endShape(CLOSE);
    }
  }

  // 绘制内表面
  if (shellShader != null) {
    shellShader.set("uInteriorFactor", 1.0f);
  }
  for (int i = 0; i < ringCount - 1; i++) {
    for (int j = 0; j < vertexCount; j++) {
      int nextJ = (j + 1) % vertexCount;
      PVector inner00 = getAnimatedInnerPoint(i, j);
      PVector inner01 = getAnimatedInnerPoint(i, nextJ);
      PVector inner11 = getAnimatedInnerPoint(i + 1, nextJ);
      PVector inner10 = getAnimatedInnerPoint(i + 1, j);
      beginShape(QUADS);
      emitVertexWithNormal(inner00, innerNormals[i][j]);
      emitVertexWithNormal(inner01, innerNormals[i][nextJ]);
      emitVertexWithNormal(inner11, innerNormals[i + 1][nextJ]);
      emitVertexWithNormal(inner10, innerNormals[i + 1][j]);
      endShape(CLOSE);
    }
  }

  // 绘制侧面
  if (shellShader != null) {
    shellShader.set("uInteriorFactor", 0.35f);
  }
  for (int i = 0; i < ringCount; i++) {
    for (int j = 0; j < vertexCount; j++) {
      int nextJ = (j + 1) % vertexCount;
      PVector n0 = computeSideNormal(i, j);
      PVector n1 = computeSideNormal(i, nextJ);
      PVector outer0 = getAnimatedOuterPoint(i, j);
      PVector outer1 = getAnimatedOuterPoint(i, nextJ);
      PVector inner1 = getAnimatedInnerPoint(i, nextJ);
      PVector inner0 = getAnimatedInnerPoint(i, j);
      beginShape(QUADS);
      emitVertexWithNormal(outer0, n0);
      emitVertexWithNormal(outer1, n1);
      emitVertexWithNormal(inner1, n1);
      emitVertexWithNormal(inner0, n0);
      endShape(CLOSE);
    }
  }

  // 绘制首端面
  if (shellShader != null) {
    shellShader.set("uInteriorFactor", 0.55f);
  }
  PVector frontNormal = computeCapNormal(0, true);
  for (int j = 0; j < vertexCount; j++) {
    int nextJ = (j + 1) % vertexCount;
    PVector outer0 = getAnimatedOuterPoint(0, j);
    PVector outer1 = getAnimatedOuterPoint(0, nextJ);
    PVector inner1 = getAnimatedInnerPoint(0, nextJ);
    PVector inner0 = getAnimatedInnerPoint(0, j);
    beginShape(QUADS);
    emitVertexWithNormal(outer0, frontNormal);
    emitVertexWithNormal(outer1, frontNormal);
    emitVertexWithNormal(inner1, frontNormal);
    emitVertexWithNormal(inner0, frontNormal);
    endShape(CLOSE);
  }

  // 绘制尾端面
  int lastIndex = ringCount - 1;
  if (shellShader != null) {
    shellShader.set("uInteriorFactor", 0.45f);
  }
  PVector backNormal = computeCapNormal(lastIndex, false);
  for (int j = 0; j < vertexCount; j++) {
    int nextJ = (j + 1) % vertexCount;
    beginShape(QUADS);
    emitVertexWithNormal(getAnimatedOuterPoint(lastIndex, j), backNormal);
    emitVertexWithNormal(getAnimatedOuterPoint(lastIndex, nextJ), backNormal);
    emitVertexWithNormal(getAnimatedInnerPoint(lastIndex, nextJ), backNormal);
    emitVertexWithNormal(getAnimatedInnerPoint(lastIndex, j), backNormal);
    endShape(CLOSE);
  }

  popStyle();
}

void updateShapeFromControlVertices() {
  PVector center = getControlCenter();
  float aspectRatio = lerp(1.0f, 0.2f, constrain(openingFlatten, 0, 1));
  float rotationRad = radians(openingRotationDeg);
  float cosRot = cos(rotationRad);
  float sinRot = sin(rotationRad);
  float controlRadius = 50;
  float angleStep = TWO_PI / max(vertexCount, 1);

  for (int i = 0; i < controlVertices.length; i++) {
    float baseAngle = i * angleStep;
    float x = cos(baseAngle) * controlRadius;
    float y = sin(baseAngle) * controlRadius;

    y *= aspectRatio; // 扁平化，minor axis = aspectRatio

    float xr = x * cosRot - y * sinRot;
    float yr = x * sinRot + y * cosRot;

    float scaledRadius = sqrt(xr * xr + yr * yr) / controlRadius;
    shape[i].x = scaledRadius;
    shape[i].y = atan2(yr, xr);

    controlVertices[i].set(center.x + xr, center.y + yr);
  }
}

int getVisibleRingCount() {
    return constrain(numberOfStepGrowth, 0, rings.length);
}

PVector getAnimatedRingPoint(int ringIndex, int vertexIndex) {
    return rings[ringIndex][vertexIndex];
}

PVector getAnimatedOuterPoint(int ringIndex, int vertexIndex) {
    return ringsOuter[ringIndex][vertexIndex];
}

PVector getAnimatedInnerPoint(int ringIndex, int vertexIndex) {
    return ringsInner[ringIndex][vertexIndex];
}

// 添加新的绘制方法
void drawWireSurface() {
  float strokeWeightValue = 0.5 / zoom; // 保持缩放一致的线条宽度
  strokeWeight(strokeWeightValue);
  int ringCount = getVisibleRingCount();
  if (ringCount < 2) {
    return;
  }
  for (int i = 0; i < ringCount - 1; i++) {
    for (int j = 0; j < vertexCount - 1; j++) {
      PVector p00 = getAnimatedRingPoint(i, j);
      PVector p01 = getAnimatedRingPoint(i, j + 1);
      PVector p11 = getAnimatedRingPoint(i + 1, j + 1);
      PVector p10 = getAnimatedRingPoint(i + 1, j);
      beginShape();
      vertex(p00.x, p00.y, p00.z);
      vertex(p01.x, p01.y, p01.z);
      vertex(p11.x, p11.y, p11.z);
      vertex(p00.x, p00.y, p00.z);
      endShape(CLOSE);

      beginShape();
      vertex(p00.x, p00.y, p00.z);
      vertex(p10.x, p10.y, p10.z);
      vertex(p11.x, p11.y, p11.z);
      vertex(p00.x, p00.y, p00.z);
      endShape(CLOSE);
    }

    // 处理首尾相连的部分
    PVector pStartCurrent = getAnimatedRingPoint(i, vertexCount - 1);
    PVector pStartNext = getAnimatedRingPoint(i + 1, vertexCount - 1);
    PVector pFirstCurrent = getAnimatedRingPoint(i, 0);
    PVector pFirstNext = getAnimatedRingPoint(i + 1, 0);
    beginShape();
    vertex(pStartCurrent.x, pStartCurrent.y, pStartCurrent.z);
    vertex(pFirstCurrent.x, pFirstCurrent.y, pFirstCurrent.z);
    vertex(pFirstNext.x, pFirstNext.y, pFirstNext.z);
    vertex(pStartCurrent.x, pStartCurrent.y, pStartCurrent.z);
    endShape();

    beginShape();
    vertex(pStartCurrent.x, pStartCurrent.y, pStartCurrent.z);
    vertex(pStartNext.x, pStartNext.y, pStartNext.z);
    vertex(pFirstNext.x, pFirstNext.y, pFirstNext.z);
    vertex(pStartCurrent.x, pStartCurrent.y, pStartCurrent.z);
    endShape();
  }
}

// 添加增量控制方法
